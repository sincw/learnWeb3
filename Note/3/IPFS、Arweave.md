# IPFS

去中心化分布式文件系统，可能成为bittorent

### 1、概述

##### 简介

        IPFS是一种内容可寻址、点对点、分布式文件系统。IPFS采用内容-地址寻址技术，即通过文件内容进行检索而不是通过文件的网络地址。简单来说，就是对文件内容进行hash运算，将hash值作为文件名保存在本地数据库中，所以，只要文件内容不变，则文件名也保持不变。

##### IPFS的文件存储形式

        多个运行IPFS程序的节点构成IPFS存储网络，存储在IPFS网络中的数据被划分成多个块，存放在不同节点中。当节点请求网络中的数据时，会在节点本地缓存该文件。即每个节点都保存其下载过的文件的缓存，用来保证即使某一个存有该资源的节点推出IPFS网络，该资源仍然可以被其他节点访问。

        当用户把文件上传到IPFS节点存储时，节点会将文件分块后进行存储，每个文件块以Merkle有向无环图（如图1所示）的形式组织，而Merkle有向无环图的根哈希则用来表示该文件。同时采用分布式Hash表（如图2所示）实现通过hash值到文件内容的定位。

![](image\o4YBAF-Y5OeAEK03AAHTmjbYs-g645.png)

### 2、IPFS原理

##### ipfs  add file  过程

当文件添加到 IPFS 时，文件（大于256 k）会被拆分为更小的块，经过加密散列（hash），并被赋予一个称为内容标识符 (CID) 的唯一指纹。而每一个文件片段的 CID 又可以生成整个文件的 hash 过后的 CID。所以在 ipfs 中，每一个资源对象都有一个独一无二的 CID。而 CID 就是内容寻址的重要组成部分。

![](image\v2-43479af366149e34364adc3211ca8b45_720w.webp)

文件的内容是 hash 了的，也就是说，内容无法篡改或者修改，因为一旦修改 hash 值的内容就不一样了。但是修改有时有时不可避免的。于是 ipfs 就借鉴了 git 的思想（实际上是几乎原封不动的把 git 的代码拷贝了过来）。通过 git 的版本控制，来串联起同一文件不同版本的关系。但是新的文件和以前的文件已经不是同一份文件了。比如你上传了一本小说，你改了其中一段话重新上传，其中一个cid所指的文件就有版本变化，整个文件的cid就发生了变化。如果你任然想用原来的cid来查询就查询不到新的文件，这里引入IPNS来解决这个问题。

##### Merkle有向无环图   DAG

节点有先后顺序，可以分叉，但不会有环。

DAG的缺点，他的交易必然是延迟的，因为DAG的验证规则是后面的交易验证前面的交易，但随着节点的增加，这种延迟会好很多。链式结构保证了区块的的一致性，但是DAG是异步操作，没有排序，会导致节点间存储的数据在运行一段时间后出现偏差。双花，一个节点确认时并可能看不到双花的两个分片。会有冗余的交易。

aptos批量处理，共识合并。

入下图所示,向ipfs上传了一个文件夹

文件结构如下，，，其中hello.txt和myfile.txt文件内容相同，bigfile大小超过 256k

----root_dir_

--------bigfile.js

--------my_dir

------------my_file.txt

------------testing.txt

--------hello.txt

![](image\1463289-20211207135606305-684844323.jpg)

##### ipfs存储结构

本地表中存储文件的K/V值。正如前面所提到的，每个文件在保存到 IPFS 网络中都可能进行分片，即把大的文件分成小的碎片，每个碎片有自己的哈希，根据碎片的哈希生成对应的 Link，以碎片在文件中出现的顺序，使用这些 Link 生成连接数组，使用连接数组生成最终的顶层 Object 对象，以此来表示文件。每一个分块都可以作为Object对象进行访问。

![](image\1463289-20211207135758567-998153875.png)

##### Kademlia DHT

分布式hash表，当存储小文件时，会直接将该文件存到DHT（分布式hash表）上。存储大文件时，会存储文件的根hash和对应节点的ID。

        Kademlia DHT是一种分布式哈希算法。

假设现在所有的文件被分布式存储在不同的机器上，如果我们想要查询a的位置，应该去哪个机器上查询？

一种思路就是所有的节点都存储所有文件存放的位置。但这样的弊端是显而易见的：

一方面如果有一个新的文件加入到系统中，那么需要把它的位置广播给所有的节点，开销很大。另一方面，一但有一个节点被攻破，那么攻击者就可以的得知所有的文件存储的位置，不安全。

详见   分布式哈希DHT

### CID

内容标识符

##### IPNS

    访问ipfsfirst.com等普通网站时，网络会将其转换为IP地址，例如216.58.216.14或2607：f8b0：4003：c00 :: 6a。然后，您的计算机将连接到地址所指向的服务器并询问：“您能给我发送ipfsfirst.com的内容吗?” ，您将收到网站相关的内容。

　　但是，在IPFS上，当您要求某些内容时，您不会从网络请求IP地址，而是要求提供文件的哈希值 - 网页，图像，视频或其他内容。在ipfs中，一个文件的Hash值完全取决于其内容，修改它的内容，其相应的Hash值也会发生改变，这样会带来很多不便。例如，如果HTML网页使用其引用嵌入图像，则每次更新图像时都需要更新引用，否则网页仍将引用旧版本的图像。如果许多网页中包含相同的图像，则所有这些图像哈希值也要改变，都需要更新。

　　显然，人们仍然希望能够在不破坏其所有链接的情况下更改其内容。为此，我们就需要一种来标记更新网址哈希的方法，没错，这个方法就是 IPNS，星际名称系统。IPNS允许您使用类似哈希的地址安全地指向可变内容(/ ipns /)。

　　使用IPNS(去中心化命名系统)，每个文件都可以被协作命名为易读的名字。通过搜索，就能很容易地找到想要查看的文件。

##### 节点加入

（1）新节点加入情况：

　　当有新节点N加入时，需要通过访问网络中的任一节点S ​，​以S​作为中介加入网络，具体来说：

- ​将S加入本地路由表，​成为N的种子节点；
- ​N向S​发起一次节点查询请求，查询的目的节点其实是​自身；该请求的目的有二：第一告诉S新增了节点N​，第二​通过​S发现集群中更多的节点。而​发起了指向自身的查询请求也很有意思：其一是因为N​此时还不知道系统更多的节点信息；其二是通过这种方式N可以快速地找到更多距离自己更接近的节点。
- ​S收到N的查询目标节点​请求，首先将​节点N加入自身的路由表中，然后给​ N最多返回K个距离N更接近的节点信息；
- ​N收到S的响应，将响应中的节点加入自身路由表，然后对这些节点分别发起查询请求，当然，查询的目标还是​自身。
- 最后，节点N在更新路由表的过程中，主动存储文件Hash值距离自己比访问节点更近的数据文件。

（2）节点离线：

　　节点离线在Kademlia协议中无需做特殊处理，如果

某个节点离线，那么其离线事件最终会反馈到网络节点的路由表中，将其从路由表中剔除即可。

（3）数据冗余存储：

　　并不能保证在任一时刻目标节点N均一定存在或者在线，因此Kad网络规定：任一条目，依据其key的具体取值，该条目将被复制并存放在节点ID距离key值最近(即当前距离目标节点N最近)的k个节点当中；之所以要将重复保存k份，这完全是考虑到整个Kad系统稳定性而引入的冗余；

##### 缺点

1. 如果没有其它节点拉取该数据，就只有本机存有该数据的孤本，一旦本机出现故障，该数据就会丢失。也就是说，IPFS并不自动对数据做冗余，更没有心跳监测和自动数据重建。因此，IPFS没有数据持久性保障机制。换句话说，IPFS并不能保证所存储的数据内容永久不丢。

2. IPFS不对数据加密有直接关系。根据伦理要求，IPFS不能把数据自动推送到其它节点，以避免将色情图片推送给女性，或者将宗教禁忌内容推送给不合适的人。IPFS不加密，还直接导致了IPFS的数据安全性保障机制的缺失。上传到IPFS的数据对任何人都是开放的，只要知道Hash值就可以读取。如果说BAT这样的中心化平台会偷用户数据作恶的话，那也只是一个人偷，而将数据存储到IPFS这样的没有数据安全性保障机制的去中心化存储系统，就变成了人人都可以偷数据。

3. IPFS是完全去中心化的设计，每个节点都是对等的。每个节点维护一张DHT（分布式哈希表），包含相应数据块与目标节点的对应映射关系。整个DHT被组织成二叉树，平均查询联系节点的复杂度是O(log2N)，例如要查询1000万节点最多需要20跳。

##### 其他

开发ipfs的团队后续推出了fileCoin这一项目，激励大家建设ipfs网络。

 POS(Proof-of-Storage) 共识算法，注意这个并不是以太坊的 POS(Proof of Stake)，前者是基于存储证明，后者是基于权益证明。  
**这也说明作为 Filecoin 矿工，如果你的存储能力越强，你挖到区块的概率就会越高。**
